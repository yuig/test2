package rd2;

import bg.m;

/* loaded from: classes4.dex */
public final /* synthetic */ class a implements m {

    /* renamed from: a, reason: collision with root package name */
    public final /* synthetic */ int f107515a;

    @Override // java.util.function.Function
    public final Object apply(Object obj) {
        switch (this.f107515a) {
        }
        return "///////////////////////////////////////////////////\n/////////////////// common ////////////////////////\n///////////////////////////////////////////////////\n\n///////////////////////////////////////////////////\n/////// shader settings\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    precision highp int;\n#else\n    precision mediump float;\n    precision mediump int;\n#endif\n\nprecision mediump sampler3D;\n\n///////////////////////////////////////////////////\n/////// common constants\n\n#define PI 3.1415926538\n\n///////////////////////////////////////////////////\n/////// common functions\n\n// sample from texture with `constant` wrap mode\n// if uv coordinate is outside the [0, 1] range, `colorOutside` will be returned\nvec4 sampleWithConstantWrap(in sampler2D src, vec2 uv, vec4 colorOutside) {\n    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n        return colorOutside;\n    }\n\n    return texture(src, uv);\n}\n\nvec2 scaleUV(vec2 uv, float scale) {\n    vec2 uvNorm = (uv - 0.5) * 2.0;\n    uvNorm *= scale;\n    return (uvNorm / 2.0) + 0.5;\n}\n\nvec4 encodeItemID(int id) {\n    if (id < 0) {\n        return vec4(0.0);\n    }\n\n    int indexLo = id % 255;\n    int indexHi = id / 255 % 255;\n    return vec4(\n        float(indexLo) / 255.0,\n        float(indexHi) / 255.0,\n        0.0,\n        1.0\n    );\n}\n\nint decodeItemID(vec4 encoded) {\n    if (encoded.a < 1e-6) {\n        return -1;\n    }\n\n    // reconstruct object ID from 2 byte parts\n    int indexLo = int(round(encoded.x * 255.0));\n    int indexHi = int(round(encoded.y * 255.0));\n    return indexHi * 255 + indexLo;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// rotation around a given axis\nvec3 rotate3D(vec3 v, vec3 axis, float angle) {\n    mat4 m = rotationMatrix(axis, angle);\n    return (m * vec4(v, 1.0)).xyz;\n}\n\n// CCW rotation in XY plane\nvec2 rotate2D(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, s, -s, c);\n    return m * v;\n}\n\nvec3 random(vec3 x) {\n    return mod(\n        x * ((x*34.0) + 1.0),\n        289.0\n    );\n}\n\nfloat random(vec2 st) {\n    return fract(\n        43758.5453123 * sin(\n            dot(st.xy, vec2(12.9898,78.233))\n        )\n    );\n}\n\nfloat random(float p) {\n    return random(vec2(p));\n}\n\nfloat simplexNoise2D(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n             -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = random(random( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n      dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat gaussian2D(float x, float y, float sigma) {\n    return exp(-(x * x + y * y) / (2.0 * sigma * sigma)) / (2.0 * PI * sigma * sigma);\n}\n\nfloat gaussian1D(float x, float sigma)\n{\n    return 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n}\n\nfloat luminance(vec3 c) {\n    return dot(vec3(0.299, 0.587, 0.114), c);\n}\n\nvec3 RGB2HSL(vec3 src) {\n     float r = src.r;\n     float g = src.g;\n     float b = src.b;\n\n     float cMax = max(max(r, g), b);\n     float cMin = min(min(r, g), b);\n     float delta = cMax - cMin;\n\n     float hue;\n     if(delta == 0.0) {\n         hue = 0.0;\n     } else if (cMax == r) {\n         hue = 60.0 * ( mod((g - b) / delta, 6.0) );\n     } else if (cMax == g) {\n         hue = 60.0 * ((b - r) / delta + 2.0);\n     } else {\n         hue = 60.0 * ((r - g) / delta + 4.0);\n     }\n\n     float lightness = (cMax + cMin) / 2.0;\n\n     float saturation = 0.0;\n     if(delta != 0.0) {\n         saturation = delta / (1.0 - abs(2.0 * lightness - 1.0));\n     }\n\n     return vec3(hue, saturation, lightness);\n }\n\n vec3 HSL2RGB(vec3 src) {\n     float h = src.x;\n     float s = src.y;\n     float l = src.z;\n\n     float c = (1.0 - abs(2.0 * l - 1.0)) * s;\n     float x = c * (1.0 - abs(mod(h / 60.0, 2.0) - 1.0));\n     float m = l - c / 2.0;\n\n     float r = 0.0, g = 0.0, b = 0.0;\n     if(h < 60.0) {\n         r = c;\n         g = x;\n     } else if (h < 120.0) {\n         r = x;\n         g = c;\n     } else if (h < 180.0) {\n         g = c;\n         b = x;\n     } else if (h < 240.0) {\n         g = x;\n         b = c;\n     } else if (h < 300.0) {\n         r = x;\n         b = c;\n     } else {\n         r = c;\n         b = x;\n     }\n\n     return vec3(r + m, g + m, b + m);\n }\n\nvec3 RGBtoXYZ( vec3 c ) {\n    vec3 tmp;\n    tmp.x = ( c.r > 0.04045 ) ? pow( ( c.r + 0.055 ) / 1.055, 2.4 ) : c.r / 12.92;\n    tmp.y = ( c.g > 0.04045 ) ? pow( ( c.g + 0.055 ) / 1.055, 2.4 ) : c.g / 12.92,\n    tmp.z = ( c.b > 0.04045 ) ? pow( ( c.b + 0.055 ) / 1.055, 2.4 ) : c.b / 12.92;\n    return 100.0 * tmp *\n        mat3( 0.4124, 0.3576, 0.1805,\n              0.2126, 0.7152, 0.0722,\n              0.0193, 0.1192, 0.9505 );\n}\n\nvec3 XYZtoRGB( vec3 c ) {\n    vec3 v =  c / 100.0 * mat3( \n        3.2406, -1.5372, -0.4986,\n        -0.9689, 1.8758, 0.0415,\n        0.0557, -0.2040, 1.0570\n    );\n    vec3 r;\n    r.x = ( v.r > 0.0031308 ) ? (( 1.055 * pow( v.r, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.r;\n    r.y = ( v.g > 0.0031308 ) ? (( 1.055 * pow( v.g, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.g;\n    r.z = ( v.b > 0.0031308 ) ? (( 1.055 * pow( v.b, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.b;\n    return r;\n}\n\nvec3 XYZtoLAB( vec3 c ) {\n    vec3 n = c / vec3( 95.047, 100, 108.883 );\n    vec3 v;\n    v.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n    v.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n    v.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n    return vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 LABtoXYZ( vec3 c ) {\n    float fy = ( c.x + 16.0 ) / 116.0;\n    float fx = c.y / 500.0 + fy;\n    float fz = fy - c.z / 200.0;\n    return vec3(\n         95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n        100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n        108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n    );\n}\n\nvec3 RGBtoLAB(vec3 c) {\n    vec3 lab = XYZtoLAB( RGBtoXYZ( c ) );\n    return vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 LABtoRGB(vec3 c){\n    return XYZtoRGB(LABtoXYZ(vec3(100.*c.x,2.*127.*(c.y-.5),2.*127.*(c.z-.5))));\n}\n\n///////////////////////////////////////////////////\n// effects-related data structures\n\nstruct VertexEffectInput {\n    vec3 position;           // vertex coordinates [-1, 1]\n    vec2 texturePosition;    // texture (uv) coordinates [0, 1]\n    vec2 size;               // original item size in pixels\n    float time;              // time in seconds\n};\n\nstruct FragmentEffectInput {\n    vec4 color;           // source color at a given position\n    vec3 position;        // vertex coordinates [-1, 1]\n    float time;           // time in seconds\n    vec2 texturePosition; // texture (uv) coordinates [0, 1]\n    vec2 size;            // original item size in pixels\n    int itemID;           // unique item ID\n};\n\n///////////////////////////////////////////////////";
    }
}
